#define _CRT_SECURE_NO_WARNINGS 1
#pragma warning(disable:6031)
#include<stdio.h>
//如果小数点后位数太多,就可能导致浮点数在内存中无法精确地保存
//int main()
//{
//	float f = 5.5;
//	//5.5 - 转换成二进制数字 101.1
//	//转换成V = (-1)^0 *1.011*2^2
//	//即 S = 0,M = 1.011 ,E = 2
//	// 对于E的存储 要加上一个中间数 单精度浮点数为127 双精度浮点数为1023 E = 2+127 = 129
//	//对于32位单精度浮点数 最高的1位存储符号位S,接着的8位存储E,剩下的23位存储有效数字M
//	// 对于E的存储,只存储小数点后面的小数 011 不够23位补0
//	// 010000000101100000000000000000000
//	//转成16进制数字
//	//40 B0 00 00-小端字节序存储方式
//	return 0;
//}


int main()
{
	int n = 9;//整型9存放的二进制序列为 00000000 00000000 00000000 00001001
	float* pfloat = (float*)&n;//&n类型为int* 强制类型转换成float*
	//Pfloat会认为9存放的二进制序列是浮点数的存储方式
	//0 00000000 00000000000000000001001 
   // S  E        M
   // E的真实值为1-127  = -126
   // 有效数字M,取出后不再加上第一位的1
   //(-1)^0 * 0.00000000000000000001001 *2^-126约等于0
	//float单精度浮点数只精确到小数点后六位
	printf("n的值为:%d\n", n);//9
	printf("pfloat的值为:%f\n", *pfloat);//所以打印结果为 0.000000

	*pfloat = 9.0;//以浮点数的形式存储
	//1001.0 = 1.001*2^3  = (-1)^0 *1.001*2^3
	// E = 3 E+127 = 130
	// M为001
	// 0 100000010 00100000000000000000000 - 以浮点数存储的二进制序列
	//以有符号数的形式打印,最高位为0 0为正数,整数的原码反码补码相同-直接转成十进制数字
	printf("n的值为:%d\n", n);//1091567616
	printf("*pfloat的值为:%f\n", *pfloat);//9.000000
	return 0;
}