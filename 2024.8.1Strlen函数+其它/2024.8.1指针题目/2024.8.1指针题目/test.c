#define _CRT_SECURE_NO_WARNINGS 1
#pragma warning(disable:6031)
#include<stdio.h>
#include<Stdlib.h>
int main()
{
	char* a[] = { "work","at","xxx" }; //a的类型为为数组指针,
	char** pa = a;//a是数组指针首元素的地址 把他赋值为二级指针pa
	pa++;//pa++为跳过一个字符指针 指向第二个字符的地址
	printf("%s\n", *pa);//结果为at 当使用%s来打印一个字符串的地址时,实际上是打印地址指向的字符串
	//%s-需要一个字符串的起始地址 通过字符串的起始地址来打印字符串
	return 0;
}

int main2()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
	int* ptr1 = (int*)(&aa + 1);//&aa为二维数组的地址 &aa+1为跳过整个数组指向元素10的末地址
	int* ptr2 = (int*)(*(aa + 1));//aa为二维数组首元素地址 aa+1为二维数组跳过第一行 就是元素5的末地址
	printf("%d %d", *(ptr1 - 1), *(ptr2 - 1));//10 5
	//*(ptr1-1),ptr1类型为int* 所以*(ptr1-1)解引用是元素10
	//*(ptr2-1)类型为int* -1后指向元素5的起始地址 所以结果为5
	return 0;
}

//int main1()
//{
//	//但p的类型是int*[4] a的类型是int*[5]会有警告
//	int a[5][5];//a为二维数组
//	int(*p)[4];//p是指针数组
//	p = a;//把a赋值给p a为二维数组第一行的地址 类型为 int* [5]
//	printf("%p %d", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//FFFFFFFC -4
//	//二维数组展示,以下标为例
//	//零 0 1 2 3 4   一 0 1 2 3 4  二 0 1 2 3 4  三 0 1 2 3 4  四 0 1 2 3 4个
//	// (*(p+4)+2) p为数组指针,p指向的数组是四个整型长度 p+4=跳过四个有四个整型元素的数组到第第四行下标为三的第一列 
//	// *(p+4)解引用后第四行下标为三的第一列元素的起始地址,类型为int* (*(p+4)+2)再+2为跳过两个整型到第四行下标为三的第3的元素的起始地址
//	// &a[4][2]为第五行第三个元素
//	//指针-指针=两个指针之间有多少个元素
//	// 地址从低到高排列 所以&p[4][2]-&a[4][2]为高地址-低地址为负数
//	// 他们两个之间相差4的元素 所以%d打印结果为-4
//	// -4的原码10000000 00000000 00000000 00000100
//	// 反码:111111111 111111111 111111111 11111011-符号位不变,其他位依次按位取反
//	// 补码:111111111 111111111 111111111 11111100-反码+1=补码
//	// 十六进制的地址值%p FFFFFFFC 四位二进制数字换一位16进制数组,最后不够直接换算
//	//所以&p[4][2]指向第四行的0下标元素的起始地址 &p[4][2] = (*(*p+4)+2)
//	return 0;
//}
